import Class.Functor (..)

operator (<*<) =
  { fixity = Left
    precedence = 4
    opname = "leftwards splat"
  }

operator (>*>) =
  { fixity = Right
    precedence = 4
    opname = "rightwards splat"
  }

operator (-*>) =
  { fixity = Right
    precedence = 4
    opname = "discard splat rightwards"
  }

operator (>*-) =
  { fixity = Right
    precedence = 4
    opname = "rightwards splat discard"
  }

module Applicative where

-- This lawless type should probably be hidden inside another module?
-- Otherwise, in some cases, type inference will end up generating
-- foo : (Pointed f, Apply f) => .. for some local function, which isn't good..
-- We probably don't even need this if we're using profunctor optics.
-- See http://oleg.fi/gists/posts/2017-03-20-affine-traversal.html#s:1
mod type Pointed f where
  -- | Lift a value.
  pure : a -> f a

mod type Apply f where
  -- Syntactic sugar for
  -- has .. : Functor f
  has Functor f

  --| Right to left sequential application.
  (<*<) : f (a -> b) -> f a -> f b
  (<*<) = liftA2 identity

  -- Q: Does this introduce an additional
  -- liftA2 : (M : Apply f) => ... in the outer scope?
  liftA2 : (a -> b -> c) -> f a -> f b -> f c
  liftA2 g x y = g <|< x <*< y

implicit type Applicative f where
  -- Sugar for
  -- has .. : Pointed f
  -- has .. : Apply f
  has Pointed f, Apply f

-- Transparent ascription, analogous to <: in OCaml 4.08 and above.
-- See https://blog.janestreet.com/plans-for-ocaml-408/
implicit ApplicativeMaybe = MonadMaybe : Applicative Maybe

-- | Left to right sequential application.
(>*>) : (M : Apply f) => f a -> f (a -> b) -> f b
(>*>) = flip M.(<*<)

-- | Sequence actions from left to right, discarding the left argument.
(-*>) : (M : Apply f) => f a -> f b -> f b
(-*>) = M.liftA2 (flip const)

-- | Sequence actions from left to right, discarding the right argument.
(>*-) : (M : Apply f) => f a -> f b -> f a
(>*-) = M.liftA2 const
