import Class.Functor (..)

operator (<*<) =
  { fixity = Left
    precedence = 4
    opname = "leftwards splat"
  }

operator (>*>) =
  { fixity = Right
    precedence = 4
    opname = "rightwards splat"
  }

operator (-*>) =
  { fixity = Right
    precedence = 4
    opname = "discard splat rightwards"
  }

operator (>*-) =
  { fixity = Right
    precedence = 4
    opname = "rightwards splat discard"
  }

module Class.Applicative where

mod type Pointed f where
  --| Lift a value.
  pure : a -> f a

mod type Apply f where
  -- Syntactic sugar for
  -- has .. : Functor f
  has Functor f

  --| Right to left sequential application.
  (<*<) : f (a -> b) -> f a -> f b
  (<*<) = liftA2 id

  -- Q: Does this introduce an additional
  -- liftA2 : (M : Apply f) => ... in the outer scope?
  liftA2 : (a -> b -> c) -> f a -> f b -> f c
  liftA2 g x y = g <|< x <*< y

implicit type Applicative f where
  -- Sugar for
  -- has .. : Pointed f
  -- has .. : Apply f
  has Pointed f, Apply f

-- Transparent ascription, analogous to <: in OCaml 4.08 and above.
-- See https://blog.janestreet.com/plans-for-ocaml-408/
implicit ApplicativeMaybe = MonadMaybe : Applicative Maybe

-- | Left to right sequential application.
(>*>) : M : Apply f => f a -> f (a -> b) -> f b
(>*>) = flip M.(<*<)

-- | Sequence actions from left to right, discarding the left argument.
(-*>) : M : Apply f => f a -> f b -> f b
(-*>) = M.liftA2 (flip const)

-- | Sequence actions from left to right, discarding the right argument.
(>*-) : M : Apply f => f a -> f b -> f a
(>*-) = M.liftA2 const
